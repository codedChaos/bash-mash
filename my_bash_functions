# bapt() is a function that will run an `apt install` command in the background to free up your terminal
function bapt() {
    declare -gA help_msg=()
    # dump passed args to array variable
    if [[ $# -gt 1 ]]; then
        logger -s "more than one arg"
        args=("$@")
    else
        help_msg+="not enough args passed to function. Need more 2 or more arguments."
        help_msg+="USAGE: bapt <install> <appname>"
        help_msg+="The first arg passed above is the word 'install' which is the same as saying"
        help_msg+="sudo apt install"
        help_msg+="the second arguments and onward are the app names and/or options"
        help_msg+=""
        logger -s "${help_msg[@]}"
        return 1

    fi

    # test command argument. ONLY WORKING WITH "INSTALL" cmd for NOW
    case "${args[0]}" in
    install)
        logger -s "running install on ${args[@]:1}"
        ;;
    *)
        logger -s "That command is unsupported with bapt() at this time."
        logger -s "HELP MESSAGE: $help_msg[@]"
        return 1
        ;;
    esac

    sudo bash -c "apt $* -y >/dev/null 2>&1 & disown"
    apt_procID = $!

    # array to capture spawned processes and kill them at the end of script
    declare -A proc_spawns=()
    while [ True ]; do

        [[ ! $(ps -ef | grep $apt_procID | grep -v grep) ]] && logger -s "couldn't find apt! EXITING!" || logger -s "apt is RUNNING!"
        pgrep apt >/dev/null 2>&1 &
        proc_spawns+=$!
    done

    logger -s "Installation of ${args[@]} is now completed."
    if [[ -z $proc_spawns ]]; then
        for proc in $proc_spawns; do
            kill -9 $proc
        done
        unset proc_spawns
    else
        echo "INFO: No spawned background process found in: proc_spawns array"
    fi

    return 0
}

# Separate way to fail out of a function without exiting the shell
function fail() {
    : "${__fail_fast:?$1}"
}

# may not use this and instead use Logger
function echoerr() {
    printf "%s\n" "$*" >&2
}

# Function to mkdir and change to it
function mcd() {
    mkdir -p $1
    cd $1
}

# Extract function that utilizes lots of different archive tools to extract almost any type of archive
function extract() {
    if [ -z "$1" ]; then
        # display usage if no parameters given
        echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
        echo "       extract <path/file_name_1.ext> [path/file_name_2.ext] [path/file_name_3.ext]"
        return 1
    else
        for n in $@; do
            if [ -f "$n" ]; then
                case "${n%,}" in
                *.tar.bz2 | *.tar.gz | *.tar.xz | *.tbz2 | *.tgz | *.txz | *.tar)
                    tar xvf "$n"
                    ;;
                *.lzma) unlzma ./"$n" ;;
                *.bz2) bunzip2 ./"$n" ;;
                *.rar) unrar x -ad ./"$n" ;;
                *.gz) gunzip ./"$n" ;;
                *.zip) unzip ./"$n" ;;
                *.z) uncompress ./"$n" ;;
                *.7z | *.arj | *.cab | *.chm | *.deb | *.dmg | *.iso | *.lzh | *.msi | *.rpm | *.udf | *.wim | *.xar)
                    7z x ./"$n"
                    ;;
                *.xz) unxz ./"$n" ;;
                *.exe) cabextract ./"$n" ;;
                *)
                    echo "extract: '$n' - unknown archive method"
                    return 1
                    ;;
                esac
            else
                echo "'$n' - file does not exist"
                return 1
            fi
        done
    fi
}

# history Averager to find useful commands to turn into functions
function histavg() {
    results="$(history | awk '{CMD[$2]++;count++;}END { for (a in CMD)print CMD[a] " " CMD[a]/count*100 "% " a;}' | grep -v "./" | column -c3 -s " " -t | sort -nr | nl | head -n10)"
    echo "$results"
}
